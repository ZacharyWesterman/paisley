#!/usr/bin/env lua
V2 = nil --filename
V3 = {} --non-builtin commands

local PRINT_BYTECODE = false
local PRETTY_PRINT = false
local ZLIB_COMPRESS = false
local DRY_RUN = false
REPL = false
LANGUAGE_SERVER = false
SUPPRESS_AST_ERRORS = false
PRINT_AST = false
AST_AFTER_SEMANTIC = false

local ENDED = false

local OUTPUT_FILE = nil

require "src.shared.json"

--Override default "error" behavior; just print the error, not a stack trace.
local old_error = error
function error(text)
	if text then print(text) end
	old_error()
end

local function script_real_path()
	local path = arg[0]
	local windows = package.config:sub(1,1) == '\\'

	if windows then
		local ffi_installed, ffi = pcall(require, 'ffi')

		if not ffi_installed then return '' end

        ffi.cdef[[
            typedef unsigned long DWORD;
            typedef char CHAR;
            typedef DWORD ( __stdcall *GetFullPathNameA_t )(const CHAR*, DWORD, CHAR*, CHAR**);
        ]]
        local kernel32 = ffi.load("kernel32")
        local MAX_PATH = 260
        local buf = ffi.new("char[?]", MAX_PATH)
        local getFullPathName = ffi.cast("GetFullPathNameA_t", kernel32.GetFullPathNameA)
        local length = getFullPathName(path, MAX_PATH, buf, nil)
        if length == 0 then
            return '' -- Failed to get path
        else
            return ffi.string(buf, length)
        end
	else
		-- If on Linux, resolve symbolic links
        local resolvedPath = io.popen("readlink -f " .. path):read("*a")
        if resolvedPath then
            return resolvedPath:gsub("^%s*(.-)%s*$", "%1") -- Trim whitespace
        else
            return '' -- Failed to get path
        end
	end
end

---@param text string
local function is_zlib_compressed(text)
	local header = text:sub(1,2)

	if #header < 2 then return false end

    -- Convert the two bytes to integer values
    local byte1, byte2 = header:byte(1, 2)

    -- Check the zlib header
    -- The first byte (CMF - Compression Method and Flags)
    -- The second byte (FLG - Additional Flags)
    return (byte1 == 0x78) and (byte2 == 0x01 or byte2 == 0x9C or byte2 == 0xDA)
end

--@param text string
local function is_paisley_bytecode(text)
	if text:sub(1,2) ~= '[[' or text:sub(#text-1,#text) ~= ']]' then return false end
	return json.verify(text)
end

local dir = script_real_path():match('(.*[/\\])')
if dir == nil then dir = '' end

local lfs_installed, lfs = pcall(require, 'lfs')
local zlib_installed, zlib = pcall(require, 'zlib')

for i, v in ipairs(arg) do
	if v:sub(1,1) == '-' and v ~= '-' then
		if v:sub(1,2) == '-c' then
			table.insert(V3, v:sub(3,#v))
		elseif v == '--help' or v == '-h' then
			print('Paisley ' .. io.open( dir .. 'version.txt'):read() )
			print('\n' .. io.open( dir .. 'helptext.txt'):read('*all'):gsub('[\r\n]+$', ''):gsub('^[\r\n]+', '') )
			ENDED = true
		elseif v == '--version' or v == '-V' then
			print('Paisley ' .. io.open( dir .. 'version.txt'):read() )
			ENDED = true
		elseif v == '--bytecode' or v == '-b' then
			PRINT_BYTECODE = true
			PRETTY_PRINT = false
			ZLIB_COMPRESS = false
		elseif v == '--pretty' or v == '-p' then
			PRINT_BYTECODE = true
			PRETTY_PRINT = true
			ZLIB_COMPRESS = false
		elseif v == '--compress' or v == '-z' then
			PRINT_BYTECODE = true
			PRETTY_PRINT = false
			ZLIB_COMPRESS = true
		elseif v == '--dry-run' then
			DRY_RUN = true
		elseif v == '--language-server' then
			LANGUAGE_SERVER = true
		elseif v == '--no-ast-errors' then
			SUPPRESS_AST_ERRORS = true
		elseif v == '--ast' then
			PRINT_AST = true
		elseif v == '--ast-sem' then
			PRINT_AST = true
			AST_AFTER_SEMANTIC = true
		elseif v == '--repl' or v == '-r' then
			REPL = true
		else
			error('Unknown flag `'..v..'`. Try running with `--help` to see all options.')
		end
	elseif V2 then
		OUTPUT_FILE = v
		PRINT_BYTECODE = true
		if zlib_installed then
			ZLIB_COMPRESS = true
		else
			print('Warning: zlib dependency is not installed, so bytecode output will not be compressed.')
		end
	else
		V2 = v --input filename
	end
end


if ZLIB_COMPRESS and not zlib_installed then
	error('ERROR: zlib dependency is not installed. Cannot output compressed bytecode.')
end

if not ENDED and REPL then
	print('Paisley ' .. io.open( dir .. 'version.txt'):read() .. ' interactive REPL.')
	print('Type `stop` or press Ctrl-D to quit.')

	require "src.repl"
	ENDED = true
end

if not ENDED then
	if V2 == nil then
		error('Error: No input file given. Use `-` to read from stdin, or re-run with `--help` to see all options.')
	end

	if V2 == '-' then
		V2 = nil
		V1 = io.read('*all') --program text
	else
		--Read from file
		local file = io.open(V2, 'rb')

		if file then
			V1 = file:read('*all')
		else
			error('Error: Cannot open file `'..V2..'`.')
		end
	end

	function output() end

	local old_working_dir = nil
	if lfs_installed and dir ~= nil then
		old_working_dir = lfs.currentdir()
		lfs.chdir(dir)
	end

	--Check if we were given compressed bytecode
	if is_zlib_compressed(V1) then
		if not zlib_installed then
			error('Error: Cannot read compressed bytecode, zlib dependency is not installed.')
		end

		local inflated, err = zlib.inflate()(V1)
		if inflated then
			V1 = ''
			require "src.compiler" --include important stuff, but don't actually compile anything.

			--We'll instead be running raw bytecode.
			bytecode = json.parse(inflated)
		else
			error('Error during decompression: '..err)
		end
	elseif is_paisley_bytecode(V1) then
		local bc = V1
		V1 = ''
		require "src.compiler"
		bytecode = json.parse(bc)
	else
		require "src.compiler"
	end

	if PRINT_AST then ENDED = true end

	if PRINT_BYTECODE then
		if old_working_dir then
			lfs.chdir(old_working_dir)
		end

		local text = ''
		if PRETTY_PRINT then
			text = text .. '[\n'
			for i = 1, #bytecode do
				local comma = ''
				if i < #bytecode then comma = ',\n' end
				text = text .. '  '
				if i < #bytecode then text = text .. json.stringify(bytecode[i]) .. ',\n'
				else
					text = text .. '[\n'
					for k = 1, #bytecode[i] do
						text = text .. '    ' .. json.stringify(bytecode[i][k])
						if k == #bytecode[i] then text = text .. '\n' else text = text .. ',\n' end
					end
					text = text .. '  ]'
				end
			end
			text = text .. '\n]'
		else
			text = json.stringify(bytecode)
		end

		if ZLIB_COMPRESS then
			local deflated, err = zlib.deflate()(text, 'finish')
			if deflated then text = deflated else
				error('Error during compression: '..err)
			end
		end

		if OUTPUT_FILE then
			local fp = io.open(OUTPUT_FILE, 'wb')
			if not fp then
				error('Failed to write to file: '..OUTPUT_FILE)
			end

			fp:write(text)
			fp:close()
		else
			print(text)
		end

		ENDED = true
	end
end

if DRY_RUN then ENDED = true end

--Run the generated bytecode
if not ENDED and not LANGUAGE_SERVER and bytecode ~= nil then
	local tmp = ALLOWED_COMMANDS

	V1 = json.stringify(bytecode)
	V4 = os.time()
	V5 = nil

	require "src.runtime"
	ALLOWED_COMMANDS = tmp

	local socket_installed, socket = pcall(require, 'socket')

	local line_no = 0
	function output(value, port)
		if port == 1 then
			--continue program
			-- os.execute('sleep 0.01') --emulate behavior in Plasma where program execution pauses periodicaly to avoid lag.
		elseif port == 2 then
			--run a non-builtin command (currently not supported outside of Plasma)
			error('Error on line '.. line_no .. ': Cannot run program `' .. std.str(value) .. '`')
		elseif port == 3 then
			ENDED = true --program successfully completed
		elseif port == 4 then
			--delay execution for an amount of time
			os.execute('sleep ' .. value)
			V5 = nil
		elseif port == 5 then
			--get current time (seconds since midnight)
			local date = os.date('*t', os.time())
			local sec_since_midnight = date.hour*3600 + date.min*60 + date.sec

			if socket_installed then
				sec_since_midnight = sec_since_midnight + (math.floor(socket.gettime() * 1000) % 1000 / 1000)
			end

			V5 = sec_since_midnight --command return value
		elseif port == 6 then
			if value == 2 then
				--get system date (day, month, year)
				local date = os.date('*t', os.time())
				V5 = {date.day, date.month, date.year} --command return value
			elseif value == 1 then
				--get system time (seconds since midnight)
				local date = os.date('*t', os.time())
				local sec_since_midnight = date.hour*3600 + date.min*60 + date.sec

				if socket_installed then
					sec_since_midnight = sec_since_midnight + (math.floor(socket.gettime() * 1000) % 1000 / 1000)
				end

				V5 = sec_since_midnight --command return value
			end
		elseif port == 7 then
			--Print text or error
			table.remove(value, 1)
			print(std.str(value))
			io.flush()
			V5 = nil
		elseif port == 8 then
			--value is current line number
		else
			print(port, json.stringify(value))
		end
	end

	function output_array(value, port) output(value, port) end

	while not ENDED do
		RUN()
	end
end
