#!/usr/bin/env lua

local config = {
	description = "This is the Paisley compiler and runtime engine.\nhttps://github.com/ZacharyWesterman/paisley",
	name = "Paisley",
	exe = "paisley",
	version = "1.13.8",
}

local options = {
	{ description = "Prints help information",                                       long = "help",                short = "h" },
	{ description = "Prints version information",                                    long = "version",             short = "V" },
	{ description = "The next parameter is the output file",                         long = "output",              short = "o",     type = "string" },
	{ description = "Start the Paisley runtime as an interactive REPL",              long = "repl",                short = "r" },
	{ description = "Output bytecode instead of running the script",                 long = "bytecode",            short = "b" },
	{ description = "Pretty-print bytecode output",                                  long = "pretty",              short = "p" },
	{ description = "Compress bytecode output with zlib compression",                long = "compress",            short = "z" },
	{ description = "Validate the program, but don't run it",                        long = "dry-run" },
	{ description = "Output detailed info in an easy-to-parse format",               long = "language-server" },
	{ description = "Pretend that stdin input has the given filename",               long = "stdin",               type = "string", arg = "[FILE]" },
	{ description = "Don't report errors in the syntax tree",                        long = "no-ast-errors" },
	{ description = "Don't remove 'dead code' that will never get run",              long = "no-prune-dead-code" },
	{ description = "Don't allow `and` and `or` expressions to shortcut",            long = "no-shortcut" },
	{ description = "Print all generated tokens and then exit",                      long = "tokens" },
	{ description = "Print the abstract syntax tree and then exit",                  long = "ast" },
	{ description = "Print the AST after semantic analysis and then exit",           long = "ast-sem" },
	{ description = "Restrict to only features available in the Plasma build",       long = "plasma" },
	{ description = "Print introspective data about the Paisley language",           long = "introspect" },
	{ description = "If introspecting, list all functions",                          long = "functions" },
	{ description = "If introspecting, list all commands",                           long = "commands" },
	{ description = "Define an existing command on the target device",               short = "c",                  type = "array",  name = "external_cmds",   composite = true, arg = "[CMD]" },
	{ description = "If introspecting, output details about the function",           short = "if",                 type = "array",  name = "introspect_func", composite = true, arg = "[FUNC_NAME]" },
	{ description = "If introspecting, output details about the command",            short = "ic",                 type = "array",  name = "introspect_cmds", composite = true, arg = "[CMD_NAME]" },
	{ description = "Output a standalone binary (or Lua script if no output file)",  long = "standalone",          short = "s" },
	{ description = "Compress the above standalone program if possible",             long = "compress-standalone", short = "cs" },
	{ description = "Allow unrecognized commands to coerce to shell exec",           long = "shell",               short = "l" },
	{ description = "Disable features/cmds that could affect the system (e.g. `?`)", long = "sandbox" },
	{ description = "List the recommended Lua packages to be installed",             long = "rocks" },
	{ description = "The input file, or `-` to read from stdin",                     name = "input",               type = "string" },
}

--DELETE THIS WHEN MINIFYING (not needed in single-file version)
--Set the Lua search path so that we can load the rest of our code.
package.path = package.path .. ';' .. (arg[0]:match('(.*[/\\])')) .. '/?.lua'

require 'src.argparse'
local flags, args = ARG.parse_and_validate(options, config)

V2 = table.remove(args, 1)     --input file
V3 = flags.external_cmds or {} --non-builtin commands

if flags.introspect then
	require 'src.introspection'
	if flags.commands or flags.introspect_cmds then
		INTROSPECT.commands(flags.introspect_cmds)
	end
	if flags.functions or flags.introspect_func then
		INTROSPECT.functions(flags.introspect_func)
	end

	os.exit(0)
end

local PRINT_BYTECODE = false
local PRETTY_PRINT = false
local ZLIB_COMPRESS = false
local DRY_RUN = false
local STANDALONE_OUTPUT = false
local STANDALONE_COMPRESS = false
LANGUAGE_SERVER = flags.language_server
RESTRICT_TO_PLASMA_BUILD = flags.plasma
SUPPRESS_AST_ERRORS = flags.no_ast_errors
PRINT_TOKENS = flags.tokens
PRINT_AST = flags.ast
AST_AFTER_SEMANTIC = flags.ast_sem
WORKING_DIR = ''
LSP_FILENAME = flags.stdin or ''
KEEP_DEAD_CODE = flags.no_prune_dead_code
NO_SHORTCUT = flags.no_shortcut
COERCE_SHELL_CMDS = flags.shell
PGM_ARGS = {}
SANDBOX = flags.sandbox

ENDED = false

local OUTPUT_FILE = nil

error = function(msg)
	io.stderr:write(msg .. '\n')
	os.exit(1)
end

if flags.compress and not FS.rocks.zlib then
	error('Error: `zlib` dependency is not installed. Cannot output compressed bytecode.')
end

if flags.repl then
	VERSION = config.version
	require "src.repl"
	os.exit(0)
end

---@diagnostic disable-next-line
bytecode = { {} }
function output() end

--Read input file
if V2 == '-' then
	V2 = nil
	V1 = io.read('*all') --program text
else
	--Read from file
	local file = io.open(V2, 'rb')

	if file then
		V1 = file:read('*all')
	else
		error('Error: Cannot open file `' .. V2 .. '`.')
	end
end

--Remove the shebang from the beginning of the input file if there is one.
local m = V1:match('^#![^\n]*\n')
local paisley_src = V1
if m then paisley_src = V1:sub(#m + 1) end

--Check if we were given compressed bytecode
if FS.is_zlib_compressed(paisley_src) then
	if not FS.rocks.zlib then
		error('Error: Cannot read compressed bytecode, zlib dependency is not installed.')
	end

	local inflated, err = FS.rocks.zlib.inflate()(paisley_src)
	if inflated then
		V1 = ''
		require "src.compiler" --include important stuff, but don't actually compile anything.

		--We'll instead be running raw bytecode.
		bytecode = json.parse(inflated)
	else
		error('Error during decompression: ' .. err)
	end
elseif FS.is_paisley_bytecode(paisley_src) then
	local bc = paisley_src
	V1 = ''
	require "src.compiler"
	bytecode = json.parse(bc)
else
	--Compile program
	require "src.compiler"
end

if flags.language_server then os.exit(0) end

if flags.bytecode then
	local text = ''
	if flags.pretty then
		text = text .. '[\n'
		for i = 1, #bytecode do
			text = text .. '  '
			if i < #bytecode then
				text = text .. json.stringify(bytecode[i]) .. ',\n'
			else
				text = text .. '[\n'
				for k = 1, #bytecode[i] do
					text = text .. '    ' .. json.stringify(bytecode[i][k])
					if k == #bytecode[i] then text = text .. '\n' else text = text .. ',\n' end
				end
				text = text .. '  ]'
			end
		end
		text = text .. '\n]'
	else
		text = json.stringify(bytecode)
	end
	print(text)
end

if flags.bytecode or flags.ast or flags.tokens or flags.ast_sem or flags.dry_run then
	os.exit(0)
end

--Run the generated bytecode
if bytecode then
	local tmp = ALLOWED_COMMANDS

	V1 = json.stringify(bytecode)
	V4 = os.time()
	V5 = nil

	require "src.runtime"
	ALLOWED_COMMANDS = tmp

	require "src.output_pc"

	while not ENDED do
		RUN()
	end

	os.exit(0)
end

error('') --TEMP

if not ENDED then
	if PRINT_BYTECODE then
		if STANDALONE_OUTPUT then
			require "src.luac"
			text = LUAC_RUNTIME_TEXT(text)

			local PYTEXT = --[[build-replace=build.py]] io.open(dir .. 'build.py'):read('*a') --[[/build-replace]]
			PYTEXT = PYTEXT:gsub('VERSION = [^\n]+', 'VERSION = "' .. VERSION .. '"')
			PYTEXT = PYTEXT:gsub('\\', '\\\\'):gsub(
				'"', '\\"'):gsub('%$', '\\$'):gsub('`', '\\`'):gsub('!', '\\!') --Make sure bash doesn't parse the string

			--Escape strings correctly in powershell
			if WINDOWS then PYTEXT = PYTEXT:gsub('\\"', '`"') end

			local build_cmd = 'python -c "' .. PYTEXT .. '" runtime --quiet --fetch-srlua --tempdir --no-remove-debug'
			os.execute(build_cmd)

			local runtime_lua = --[[build-replace=build/runtime.lua]] io.open('.paisley-build/runtime.lua', 'r'):read(
				'*all') --[[/build-replace]]
			if not runtime_lua then
				local msg = 'ERROR: Unable to load Paisley runtime! Exiting.'
				msg = msg .. '\nTHIS IS A BUG IN THE COMPILER, NOT YOUR CODE.'
				error(msg)
			end

			if WINDOWS then
				os.execute('rmdir \\s .paisley-build')
			else
				os.execute('rm -rf .paisley-build')
			end

			--Do we want to add the shebang? No, don't think so since this will get compiled into exe.
			--text = '#!/usr/bin/env lua\n' .. text

			text = text .. runtime_lua .. LUAC_EXEC_TEXT()
		elseif ZLIB_COMPRESS then
			local deflated, err = zlib.deflate()(text, 'finish')
			if deflated then
				text = deflated
			else
				error('Error during compression: ' .. err)
			end
		end

		if OUTPUT_FILE then
			local fp = io.open(OUTPUT_FILE, 'wb')
			if not fp then
				error('Failed to write to file: ' .. OUTPUT_FILE)
			end

			if not STANDALONE_OUTPUT then
				text = '#!/usr/bin/env paisley\n' .. text

				fp:write(text)
				fp:close()
			else
				fp:close()

				--If standalone, compile lua source into bytecode
				--Strip out debug info to reduce file size
				text = LUAC_STRIP(LUAC_DUMP(text))

				--At this point, srlua exists and can be used.
				--So package this text into an executable
				local srluadir = '/tmp/paisley-build-srlua/build'
				local fp2 = io.open(srluadir .. '/luac.out', 'wb')
				if not fp2 then
					error(
						'ERROR: srlua is not installed, so the program cannot be compiled into a standalone executable. Exiting.')
				end
				fp2:write(text)
				fp2:close()

				os.execute(srluadir .. '/glue ' .. srluadir .. '/srlua ' .. srluadir .. '/luac.out ' .. OUTPUT_FILE)

				if not WINDOWS then
					os.execute('chmod +x ' .. OUTPUT_FILE) --Make executable

					if STANDALONE_COMPRESS then
						os.execute('gzexe ' .. OUTPUT_FILE) --Decrease the size of the executable
						os.execute('rm -f ' .. OUTPUT_FILE .. '~')
					end
				end
			end
		elseif ZLIB_COMPRESS and not STANDALONE_OUTPUT then
			io.write(text)
		else
			print(text)
		end

		ENDED = true
	end
end
