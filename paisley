#!/usr/bin/env lua

local config = {
	description = "This is the Paisley compiler and runtime engine.\nhttps://github.com/ZacharyWesterman/paisley",
	name = "Paisley",
	exe = "paisley",
	version = "1.13.8",
}

local options = {
	{ description = "Prints help information",                                       long = "help",                short = "h" },
	{ description = "Prints version information",                                    long = "version",             short = "V" },
	{ description = "The next parameter is the output file (use `-` for stdout)",    long = "output",              short = "o",     type = "string" },
	{ description = "Start the Paisley runtime as an interactive REPL",              long = "repl",                short = "r" },
	{ description = "Output bytecode instead of running the script",                 long = "bytecode",            short = "b" },
	{ description = "Pretty-print bytecode output",                                  long = "pretty",              short = "p" },
	{ description = "Compress bytecode output with zlib compression",                long = "compress",            short = "z" },
	{ description = "Validate the program, but don't run it",                        long = "dry-run" },
	{ description = "Output detailed info in an easy-to-parse format",               long = "language-server" },
	{ description = "Pretend that stdin input has the given filename",               long = "stdin",               type = "string", arg = "[FILE]" },
	{ description = "Don't report errors in the syntax tree",                        long = "no-ast-errors" },
	{ description = "Don't remove 'dead code' that will never get run",              long = "no-prune-dead-code" },
	{ description = "Don't allow `and` and `or` expressions to shortcut",            long = "no-shortcut" },
	{ description = "Print all generated tokens and then exit",                      long = "tokens" },
	{ description = "Print the abstract syntax tree and then exit",                  long = "ast" },
	{ description = "Print the AST after semantic analysis and then exit",           long = "ast-sem" },
	{ description = "Restrict to only features available in the Plasma build",       long = "plasma" },
	{ description = "Print introspective data about the Paisley language",           long = "introspect" },
	{ description = "If introspecting, list all functions",                          long = "functions" },
	{ description = "If introspecting, list all commands",                           long = "commands" },
	{ description = "Define an existing command on the target device",               short = "c",                  type = "array",  name = "external_cmds",   composite = true, arg = "[CMD]" },
	{ description = "If introspecting, output details about the function",           short = "if",                 type = "array",  name = "introspect_func", composite = true, arg = "[FUNC_NAME]" },
	{ description = "If introspecting, output details about the command",            short = "ic",                 type = "array",  name = "introspect_cmds", composite = true, arg = "[CMD_NAME]" },
	{ description = "Output a standalone binary (or Lua script if no output file)",  long = "standalone",          short = "s" },
	{ description = "Compress the above standalone program if possible",             long = "compress-standalone", short = "cs" },
	{ description = "Allow unrecognized commands to coerce to shell exec",           long = "shell",               short = "l" },
	{ description = "Disable features/cmds that could affect the system (e.g. `?`)", long = "sandbox" },
	{ description = "List the recommended Lua packages to be installed",             long = "rocks" },
	{ description = "The input file, or `-` to read from stdin",                     name = "input",               type = "string" },
	--[[no-install]] { description = "Compile the Paisley application into a standalone executable", long = "install" }, --[[/no-install]]
}

--DELETE THIS WHEN MINIFYING (not needed in single-file version)
--Set the Lua search path so that we can load the rest of our code.
package.path = package.path .. ';' .. (arg[0]:match('(.*[/\\])') or '.') .. '/?.lua'

require 'src.util.argparse'
local flags, args = ARG.parse_and_validate(options, config)

--[[no-install]]
if flags.install then
	require 'src.util.filesystem'
	require 'src.meta.lua'

	local fp = FS.open('paisley', true)
	if not fp then
		error('Error: Failed to open `paisley` for reading.')
	end

	local text = fp:read('*all')
	fp:close()

	if FS.os.windows then
		error('Error: Standalone executables are not yet supported on Windows.')
	end

	io.stderr:write('Concatenating Lua files...\n')
	text = LUA.minify(text, true)

	io.stderr:write('Installing Paisley...\n')

	if FS.os.windows then
		-- local fp = io.open(os.getenv('APPDATA') .. '\\paisley\\paisley.lua', 'wb')
	else
		--Write the minified Lua code to the installation directory
		local fp = io.open('/usr/local/bin/paisley', 'wb')
		if not fp then
			error('Error: Failed to open `/usr/local/bin/paisley` for writing. Try running with `sudo`.')
		end
		fp:write('#!/usr/bin/env lua\n' .. text)

		--Make the file executable
		os.execute('chmod +x /usr/local/bin/paisley')

		--Create stdlib directory and copy the files over.
		os.execute('mkdir -p /usr/local/share/paisley')
		os.execute('cp -r stdlib /usr/local/share/paisley/')
	end

	os.exit(0)
end
--[[/no-install]]

V2 = table.remove(args, 1)     --input file
V3 = flags.external_cmds or {} --non-builtin commands

if flags.introspect then
	require 'src.util.introspection'
	if flags.commands or flags.introspect_cmds then
		INTROSPECT.commands(flags.introspect_cmds)
	end
	if flags.functions or flags.introspect_func then
		INTROSPECT.functions(flags.introspect_func)
	end

	os.exit(0)
end

LANGUAGE_SERVER = flags.language_server
RESTRICT_TO_PLASMA_BUILD = flags.plasma
SUPPRESS_AST_ERRORS = flags.no_ast_errors
PRINT_TOKENS = flags.tokens
PRINT_AST = flags.ast
AST_AFTER_SEMANTIC = flags.ast_sem
WORKING_DIR = ''
LSP_FILENAME = flags.stdin or ''
KEEP_DEAD_CODE = flags.no_prune_dead_code
NO_SHORTCUT = flags.no_shortcut
COERCE_SHELL_CMDS = flags.shell
PGM_ARGS = args --program arguments
SANDBOX = flags.sandbox

ENDED = false

error = function(msg)
	io.stderr:write(msg .. '\n')
	os.exit(1)
end

if flags.compress and not FS.rocks.zlib then
	error('Error: `zlib` dependency is not installed. Cannot output compressed bytecode.')
end

if flags.repl then
	VERSION = config.version
	require "src.util.repl"
	os.exit(0)
end

---@diagnostic disable-next-line
bytecode = { {} }
function output() end

--Read input file
if V2 == '-' then
	V2 = nil
	V1 = io.read('*all') --program text
else
	--Read from file
	local file = io.open(V2, 'rb')

	if file then
		V1 = file:read('*all')
	else
		error('Error: Cannot open file `' .. V2 .. '`.')
	end
end

--Remove the shebang from the beginning of the input file if there is one.
local m = V1:match('^#![^\n]*\n')
local paisley_src = V1
if m then paisley_src = V1:sub(#m + 1) end

--Check if we were given compressed bytecode
if FS.is_zlib_compressed(paisley_src) then
	if not FS.rocks.zlib then
		error('Error: Cannot read compressed bytecode, zlib dependency is not installed.')
	end

	local inflated, err = FS.rocks.zlib.inflate()(paisley_src)
	if inflated then
		V1 = ''
		require "src.compiler" --include important stuff, but don't actually compile anything.

		--We'll instead be running raw bytecode.
		bytecode = json.parse(inflated)
	else
		error('Error during decompression: ' .. err)
	end
elseif FS.is_paisley_bytecode(paisley_src) then
	local bc = paisley_src
	V1 = ''
	require "src.compiler"
	bytecode = json.parse(bc)
else
	--Compile program
	require "src.compiler"
end

if flags.language_server then os.exit(0) end

--Print the generated bytecode instead of running it
if flags.bytecode then
	local text = ''
	if flags.pretty then
		text = text .. '[\n'
		for i = 1, #bytecode do
			text = text .. '  '
			if i < #bytecode then
				text = text .. json.stringify(bytecode[i]) .. ',\n'
			else
				text = text .. '[\n'
				for k = 1, #bytecode[i] do
					text = text .. '    ' .. json.stringify(bytecode[i][k])
					if k == #bytecode[i] then text = text .. '\n' else text = text .. ',\n' end
				end
				text = text .. '  ]'
			end
		end
		text = text .. '\n]'
	else
		text = json.stringify(bytecode)
	end
	print(text)
end

if flags.bytecode or flags.ast or flags.tokens or flags.ast_sem or flags.dry_run then
	os.exit(0)
end

--Run the generated bytecode
if not flags.standalone and not flags.output then
	if bytecode then
		local tmp = ALLOWED_COMMANDS

		V1 = json.stringify(bytecode)
		V4 = os.time()
		V5 = nil

		require "src.runtime"
		ALLOWED_COMMANDS = tmp

		require "src.util.output_pc"

		while not ENDED do
			RUN()
		end
	end

	os.exit(0)
end

--TEMP: generating runtime is not supported yet.
--I want it to be bigger and better (with multiple different targets!), so for now, lock that functionality off.
if flags.standalone then
	error('Error: Generating standalone executables is not supported yet.')
end

--After this point, bytecode is outputted and the program is done.
local text = json.stringify(bytecode)

--Compress bytecode if requested.
if flags.compress then
	local deflated, err = FS.rocks.zlib.deflate()(text, 'finish')
	if deflated then
		text = deflated
	else
		error('Error during compression: ' .. err)
	end
end

--Output bytecode, not an entire standalone.
if flags.output ~= '-' then
	text = '#!/usr/bin/env paisley\n' .. text
	local fp = io.open(flags.output, 'wb')
	if not fp then
		error('Error: Failed to write to file: ' .. flags.output)
	end
	fp:write(text)
	fp:close()
else
	print(text)
end

os.exit(0)
