# @brief Truncate a string with ellipsis
# @param text string The string to truncate
# @param length number The max character length
# @param suffix string? The string to append if truncating. If not specified, "..." is used.
# @return string A string with the specified length, truncated and appended with the suffix if necessary.
# @export
subroutine string.truncate
	if {&@1 <= @2} then return {@1} end
	
	return {
		@1[1:(@2 - &(@3 if @3 else "..."))]
		(@3 if @3 else "...")
	}
end

# @brief Check if a string is numeric
# @param text string The string to test
# @return boolean True if the string only contains numeric characters.
# @export
subroutine string.is_numeric
	return {@1 like '^%d+$'}
end

# @brief Check if a string only contains letters
# @param text string The string to test
# @return boolean True if the string only contains alphabetic characters.
# @export
subroutine string.is_alpha
	return {@1 like '^%a+$'}
end

# @brief Check if a string is alphanumeric
# @param text string The string to test
# @return boolean True if the string only contains alphanumeric characters.
# @export
subroutine string.is_alphanumeric
	return {@1 like '^%w+$'}
end

# @brief URL-encode a string
# @param text string The string to encode
# @return string The URL-encoded string.
# @export
subroutine string.urlencode
	define {
		!entities[(
		' ' => '%20',
		'!' => '%21',
		'"' => '%22',
		'#' => '%23',
		'$' => '%24',
		'&' => '%26',
		"'" => '%27',
		'(' => '%28',
		')' => '%29',
		'*' => '%2A',
		'+' => '%2B',
		',' => '%2C',
		'/' => '%2F',
		':' => '%3A',
		';' => '%3B',
		'<' => '%3C',
		'=' => '%3D',
		'>' => '%3E',
		'?' => '%3F',
		'@' => '%40',
		'[' => '%5B',
		'\\' => '%5C',
		']' => '%5D',
		'^' => '%5E',
		'`' => '%60',
		'{' => '%7B',
		'|' => '%7C',
		'}' => '%7D',
		'~' => '%7E',
		)]
	}

	let _url = {@1.replace('%', '%25')}
	for _key _value in {!entities.pairs()} do
		let _url = {_url.replace(_key, _value)}
	end
	delete _key _value
	return {_url}
end

# @brief URL-decode a string
# @param text string The string to decode
# @return string The URL-decoded string.
# @export
subroutine string.urldecode
	define {
		!entities[(
		' ' => '%20',
		'!' => '%21',
		'"' => '%22',
		'#' => '%23',
		'$' => '%24',
		'&' => '%26',
		"'" => '%27',
		'(' => '%28',
		')' => '%29',
		'*' => '%2A',
		'+' => '%2B',
		',' => '%2C',
		'/' => '%2F',
		':' => '%3A',
		';' => '%3B',
		'<' => '%3C',
		'=' => '%3D',
		'>' => '%3E',
		'?' => '%3F',
		'@' => '%40',
		'[' => '%5B',
		'\\' => '%5C',
		']' => '%5D',
		'^' => '%5E',
		'`' => '%60',
		'{' => '%7B',
		'|' => '%7C',
		'}' => '%7D',
		'~' => '%7E',
		)]
	}

	let _url = {@1}
	for _key _value in {!entities.pairs()} do
		let _url = {_url.replace(_value, _key)}
	end
	delete _key _value
	return {_url.replace('%25', '%')}
end

#[[
@export
@brief Convert a number to its English numeral representation (e.g., 123 -> "one hundred twenty-three").
@param number number The number to convert.
@return string The English numeral representation of the number.
#]]
subroutine string.numeral
	let _n = {abs(@[1])}

	if {_n = 0} then
		delete _n
		return zero
	end

	let _nums = one two three four five six seven eight nine
	let _rank = thousand million billion trillion quadrillion quintillion sextillion septillion octillion nonillion

	let _result = ''

	while {_n} do
		let _ones = {_n % 10}
		let _tens = {_n // 10 % 10}
		let _hundreds = {_n // 100 % 10}
		let _thousands = {_n // 1000 % 1000}

		let _r = ''
		if {_tens = 1} then
			let _r = {('ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen')[_ones+1]}
		else
			if {_ones} then let _r = {_nums[_ones]} end
			if {_tens} then
				if {_r} then let _r = "-{_r}" end
				let _r = {('twenty', 'thirty', 'fourty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety')[_tens-1] _r}
			end
		end

		if {_hundreds} then
			let _r = {_nums[_hundreds] ' hundred' (' ' if _r else '') _r}
		end

		if {_thousands} then
			let _r = {' ' _rank[1] (' ' if _r else '') _r}
		end

		let _result = {_r _result}

		let _n = {_n // 1000}
		let _rank = {_rank.delete(1)}
	end

	delete _n _nums _rank _ones _tens _hundreds _thousands _r
	return {('negative ' if @[1] < 0 else '') _result}
end

#[[
@export
@brief Convert a number to its English ordinal representation (e.g., 1 -> "first", 2 -> "second", 3 -> "third").
@param number number The number to convert.
@return string The English ordinal representation of the number.
#]]
subroutine string.ordinal
	let _r = ${gosub string.numeral {@[1]}}

	let _repl = {
		'twelve' => 'twelfth',
		'nine' => 'ninth',
		'eight' => 'eighth',
		'five' => 'fifth',
		'three' => 'third',
		'two' => 'second',
		'one' => 'first',
	}

	for _k _v in {pairs(_repl)} do
		if {_r.endswith(_k)} then
			let _r = {_r[1:(&_r - &_k)] _v}
			delete _k _v _repl
			return {_r}
		end
	end

	delete _k _v _repl

	if {_r[&_r] = 'y'} then
		return {_r[1:(&_r-1)] 'ieth'}
	end

	return {_r 'th'}
end
