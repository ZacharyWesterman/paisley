#@export
#@brief Get the current date and time.
#@return object The current date and time.
subroutine datetime.now
	return {
		'date' => ${sysdate},
		'time' => ${systime},
	}
end

#@export
#@brief Format a datetime object as a string in ISO 8601 format.
#@param datetime object The input datetime object.
#@return string The formatted string.
subroutine datetime.isoformat
	return "{date(@[1].date)}T{time(@[1].time)}"
end

#@export
#@brief Parse a string in ISO 8601 format.
#@param str string The input string to parse.
#@return object The parsed date and time.
#@mutate _dt
subroutine datetime.fromiso
	let _dt = {@[1].split('T')}
	return {
		'date' => int(i) for i in _dt[1].split('-').reverse(),
		'time' => (int(i) for i in _dt[2].split(':')).timestamp(),
	}
end

#@export
#@brief Check if a string is in ISO 8601 format.
#@param str string The input string to check.
#@return boolean True if the string is in ISO 8601 format, false otherwise.
subroutine datetime.isiso
	return {@[1] like '%d%d%d%d%-%d%d%-%d%dT%d%d:%d%d:%d%d'}
end

#@export
#@brief Parse a duration string (e.g., "1h30m") into an elapsed datetime object.
#@param duration string The duration string to parse.
#@return object The total duration.
subroutine datetime.duration
	let _d_time = 0
	let _d_date = {0, 0, 0}

	for _m in {@1.matches('%d+%s*%a+')} do
		let _number = {_m.match('%d+').num()}
		let _unit = {_m.match('%a+')[1].lower()}
		if {_unit = 'm' and _m.match('%a+')[2] = 'o'} then let _unit = 'mo' end

		match {_unit} do
			if h then let _d_time = {_d_time + _number * 60 * 60} end
			if m then let _d_time = {_d_time + _number * 60} end
			if s then let _d_time = {_d_time + _number} end
			if y then let _d_date{3} = {_d_date[3] + _number} end
			if mo then
				let _d_date{2} = {_d_date[2] + _number}
				if {_d_date[2] > 12} then
					let _d_date{3} = {_d_date[3] + (_d_date[2] - 1) / 12}
					let _d_date{2} = {(_d_date[2] - 1) % 12 + 1}
				end
			end
			if d then let _d_date{1} = {_d_date[1] + _number} end
		else
			error "Invalid duration unit: {_m.match('%a+')}"
		end
	end

	delete _m _number _unit
	return {
		'date' => _d_date,
		'time' => _d_time,
	}
end

#[[
@export
@brief Add a duration to a datetime object.
@param dt object The original datetime object.
@param duration object The duration to add.
@return object The new datetime object after addition.
#]]
subroutine datetime.add
	define {
		!january[31],
		!february[28],
		!leap_february[29],
		!march[31],
		!april[30],
		!may[31],
		!june[30],
		!july[31]
		!august[31]
		!september[30]
		!october[31]
		!november[30]
		!december[31]
		!month_days[(
			!january,
			(!february if _y % 4 else !leap_february),
			!march,
			!april,
			!may,
			!june,
			!july,
			!august,
			!september,
			!october,
			!november,
			!december,
		)[_m]]
	}

	let _t = {@1.time + @2.time}
	let _d = {@1.date[1] + @2.date[1]}
	let _m = {@1.date[2] + @2.date[2]}
	let _y = {@1.date[3] + @2.date[3]}

	while {_t >= 60 * 60 * 24} do
		let _t = {_t - 60 * 60 * 24}
		let _d = {_d + 1}
	end
	
	if {_m > 12} then
		let _y = {_y + (_m - 1) // 12}
		let _m = {(_m - 1) % 12 + 1}
	end

	let _month_days = {!month_days}
	while {_d > _month_days} do
		let _d = {_d - _month_days}
		let _m = {_m + 1}
		if {_m > 12} then
			let _y = {_y + (_m - 1) // 12}
			let _m = {(_m - 1) % 12 + 1}
		end
		let _month_days = {!month_days}
	end

	return {
		'date' => (_d, _m, _y),
		'time' => _t,
	}
end

#[[
@export
@brief Add a duration to a datetime object.
@param dt object The original datetime object.
@param duration object The duration to add.
@return object The new datetime object after addition.
#]]
subroutine datetime.sub
	define {
		!january[31],
		!february[28],
		!leap_february[29],
		!march[31],
		!april[30],
		!may[31],
		!june[30],
		!july[31]
		!august[31]
		!september[30]
		!october[31]
		!november[30]
		!december[31]
		!month_days[(
			!january,
			(!february if _y % 4 else !leap_february),
			!march,
			!april,
			!may,
			!june,
			!july,
			!august,
			!september,
			!october,
			!november,
			!december,
		)[_m]]
	}

	let _t = {@1.time - @2.time}
	let _d = {@1.date[1] - @2.date[1]}
	let _m = {@1.date[2] - @2.date[2]}
	let _y = {@1.date[3] - @2.date[3]}

	while {_t < 0} do
		let _t = {_t + 60 * 60 * 24}
		let _d = {_d - 1}
	end

	if {_m < 1} then
		let _y = {_y - 1}
		let _m = {_m + 12}
	end

	let _month_days = {!month_days}
	while {_d < 1} do
		let _d = {_d + _month_days}
		let _m = {_m - 1}
		if {_m < 1} then
			let _y = {_y - 1}
			let _m = {_m + 12}
		end
		let _month_days = {!month_days}
	end

	return {
		'date' => (_d, _m, _y),
		'time' => _t,
	}
end
