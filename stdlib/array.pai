#[[
@export
@brief Zip multiple arrays into a single array of arrays.
@param ... array The arrays to zip.
@return array[array] An array of arrays, where each inner array contains elements from the input arrays at the same index.
#]]
subroutine array.zip
	return {
		(@[i][index] for i in 1:&@)
		for index in (1:max(&i for i in @))
	}
end

#[[
@export
@brief Take the first n elements from an array.

Example usage:
```
let arr = {1, 2, 3, 4, 5}
let taken arr = {\array.take(arr, 3)}
# taken is {1, 2, 3}
# arr is {4, 5}
```

@param arr array The input array.
@param n number The number of elements to take.
@return array[array] The first n elements of the input array, and the rest as a second array.
#]]
subroutine array.take
	return {@1[1:@2], @1[(@2+1)::]}
end

#[[
@export
@brief Drop the first n elements from an array.

Example usage:
```
let arr = {1, 2, 3, 4, 5}
let arr = {\array.drop(arr, 3)}
# arr is now {4, 5}
```

@param arr array The input array.
@param n number The number of elements to drop.
@return array The array after dropping the first n elements.
#]]
subroutine array.drop
	return {@1[(@2+1)::]}
end

#[[
@export
@brief Generate the next lexicographical permutation of an array.
@param arr array The input array.
@return array? The next permutation of the array, or null if it is the last permutation.
#]]
subroutine array.permute
	let _array = {@1.reverse()}
	
	# Find the largest index _k such that _array[_k] < _array[_k + 1]. If no such index exists, the permutation is the last permutation.
	let _k = {&_array - 1}
	while {_k and _array[_k] < _array[_k + 1]} do
		let _k = {_k - 1}
	end

	if {_k = 0} then
		# This is the last permutation.
		return
	end
	
	# Find the largest index _l greater than _k such that _array[_k] < _array[_l].
	let _l = {&_array}
	while {_l and _array[_k] < _array[_l]} do
		let _l = {_l - 1}
	end

	# Swap the value of _array[_k] with that of _array[_l].
	let _temp = {_array[_k]}
	let _array{_k} = {_array[_l]}
	let _array{_l} = {_temp}

	# Reverse the sequence from _array[_k + 1] up to and including the final element _array[n].
	let _array = {
		merge(
			_array[(_k + 1)::],
			reverse(_array[1:_k]),
		)
	}

	delete _temp _start _end _k _l
	return {_array}
end
